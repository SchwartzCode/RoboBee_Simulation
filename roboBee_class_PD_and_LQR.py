import numpy as np
import matplotlib.pyplot as plt
import math
import control
import scipy
from random import seed, random

class roboBee(object):
    """  CONSTANTS & ROBOT SPECS   """
    TORQUE_CONTROLLER_CONSTANT = 0.9e-7
    B_w = 0.0002 #drag constant [Ns/m]
    Rw = 0.009
    R_w = np.array([0.0, Rw, 0.0]) #z distance between center of mass and wings [m]
    MASS = 0.08 #mass [g]
    g = 9.81 #gravity
    Jz = 0.45e-9 #Z Axis Rotational Moment of Inertia [kg*m^2]
    FLAPPING_FREQ = 120.0 #[Hz]
    WING_LENGTH = 15.0 #[mm]
    MEAN_CHORD_LENGTH = 3.46 #[mm]
    AREA = 55 #[mm^2]
    WING_INERTIA = 45.3 #inertia of wing about flapping axis [mg/mm^2]
    WING_MASS = 1.0 #[mg]
    SENSOR_NOMINAL_VAL = 1.1 #[mA]
    LAST_TORQUE_GEN = 0.0 #[Nm]


    LIFT_COEFFICIENT = 1.0
    LIFT = np.array([0.0, LIFT_COEFFICIENT*MASS*g, 0.0]) #lift force generated by wings [N]

    dt = 1/120 #1/120 #time step in seconds; represents one step at 120 Hz
    light_source_loc = np.array([0.0, 1000.0, 0.0]) #location of light source [mm]
    sensor_readings = np.array([0.0, 0.0, 0.0, 0.0]) #current flowing from phototransistors, between 1.1mA and 100 nA
    INITIAL_SENSOR_ORIENTATIONS = np.array([ [np.sqrt(0.75),   0.5,  0.0], #vectors normal to each sensor face at initial orientation (x,y,z)
                                          [0.0,             0.5,  np.sqrt(0.75)],
                                          [-np.sqrt(0.75),  0.5,  0.0],
                                          [0.0,             0.5,  -np.sqrt(0.75)]])
    sensor_readings = np.array([0.0, 0.0, 0.0, 0.0]).reshape(4,1)
    sensor_orientations = INITIAL_SENSOR_ORIENTATIONS
    state_estimate = np.array([0.0, 0.0]).reshape(2,1)




    def __init__(self):
        #unsure if this is still doing anything (it definitely doesn't LOL, fix that JONATHAN)
        self.state = np.array([0.0, 10.0, 0.0,   #position (x, y, z)
                               0.0, 0.0, 0.0,   #velocity
                               0.0, 1.0, 0.0,   #orientation (basically theta)
                               1.0, 0.0, 0.0])  #angular velocity


    def updateState_PD_Control(self, state, dt):
        """
        This function will calculate the new state using the current state
        and only a large matrix of coefficients

        This is what state space is like, where x_dot is derivative of x, which is the
        state vector, i is the input vector, and A and B are coefficient matrices:

                            x_dot = A*x + B*i


        ==== ARGUMENTS ====
        state = current state (12 double numpy 1D array)
            state[0] = theta (angle of rotation from intertial to global coords in 2D)
            state[1] = theta_dot (change in theta per unit time)
            state[2] = x axis position in global coordinates
            state[3] = x_dot (x axis velocity)
        dt = time step [seconds], usually 1/120 (wings flap at 120 Hz)
        """

        #These are 'inputs' because the torque controller is proportional to theta
        #and theta_dot (it's a PD controller if you've taken a controls course)
        #    In the future this will be elsewhere, just keeping it to evaluate
        #    This controller against the analytical one I

        u = np.zeros(4)
        u[0] = state[0]
        u[1] = state[1]


        A = np.zeros((4, 4))
        B = np.zeros((4, 4))
        #Derivative of angular positon is angular velocity
        A[0,1] = 1
        #Derivative of position is velocity
        A[2,3] = 1

        # V_x_dot terms
        A[3,0] = self.g*self.LIFT_COEFFICIENT
        A[3,3] = -self.B_w

        # Theta_dot term(s)
        A[1,3] = -self.Rw*self.B_w / self.Jz


        #Apply input torque (as of now this is just the torque generated by torque
        #controller that keeps robot upright)
        torque_constant_prop = 4e-7
        torque_constant_deriv = 0.7e-7
        B[1,0] = -torque_constant_prop / self.Jz
        B[1,1] = -torque_constant_deriv / self.Jz


        state_dot = A.dot(state) + B.dot(u)

        #applied torque is returned and stored as data to train a neural network
        torque_applied = B.dot(u)[1]

        new_state = state.copy() + state_dot.copy() * dt

        return new_state, torque_applied


    def updateState_LQR_Control(self, state, dt, state_desired, gains):
        """
        This function will calculate the new state using the current state
        and only a large matrix of coefficients, this is necessary
        in order to use LQR control.

        This is what state space is like, where x_dot is deriv of x, which is the
        state vector, i is the input vector, and A and B are coefficient matrices:

                            x_dot = A*x + B*i


        ==== ARGUMENTS ====
        state = current state (12 double numpy 1D array)
            state[0] = theta (angle of rotation from intertial to global coords in 2D)
            state[1] = theta_dot (change in theta per unit time)
            state[2] = x axis position in global coordinates
            state[3] = x_dot (x axis velocity)
            state[4] = z axis position in global coordinates
            state[5] = z_dot (z axis velocity)
        dt = time step [seconds], usually 1/120 (wings flap at 120 Hz)
        """

        #These are 'inputs' because the torque controller is proportional to theta
        #and theta_dot (it's a PD controller if you've taken a controls course)
        #    In the future this will be elsewhere, just keeping it to evaluate
        #    This controller against the analytical one I


        A = np.zeros((4, 4))
        B = np.zeros(4).reshape(4,1)
        #Derivative of angular positon is angular velocity
        A[0,1] = 1
        #Derivative of position is velocity
        A[2,3] = 1

        # V_x_dot terms
        A[3,0] = self.g*self.LIFT_COEFFICIENT
        A[3,3] = -self.B_w / self.MASS

        # Theta_dot term(s)
        A[1,3] = -self.Rw*self.B_w / self.Jz

        #Note: There are no terms in the A matrix for V_z_dot because that is
        #   controlled by the altitude controller which is decoupled from this
        #   controller (the latitude controller)


        #Coefficients for input matrix B
        B[1] = 1 #/ self.Jz



        state_dot_lat = (A - (B * gains)) * state[:4] + B * gains * state_desired[:4]


        self.LAST_TORQUE_GEN = state_dot_lat[1,0]

        """  ALTITUDE CONTROLLER
                All it does is adjust the lift force based on where the robot is
                is to its desired altitude

            # JONATHAN: can probably make the logic here a bit simpler
        """

        adjustment = 0.02
        if (state[5] > 0 and state[5] > (state_desired[4] - state[4])):
            state[5] -= adjustment
        elif (state[5] < 0 and state[5] < (state_desired[4] - state[4])):
            state[5] += adjustment
        else:
            self.LIFT_COEFFICIENT = 1 + (state_desired[4] - state[4])

        if (self.LIFT_COEFFICIENT > 1.5):
            self.LIFT_COEFFICIENT = 1.5
        elif (self.LIFT_COEFFICIENT < 0.5):
            self.LIFT_COEFFICIENT = 0.5


        state_dot_alt = np.array([state[5], self.MASS*self.g*(self.LIFT_COEFFICIENT*np.cos(state[0]) - 1)]).reshape(2,1)


        state_dot = np.vstack([state_dot_lat, state_dot_alt])

        new_state = state + state_dot*dt

        return new_state, state_dot_lat[1]


    def LQR_gains(self):
        A = np.zeros((4, 4))
        B = np.zeros(4).reshape(4,1)
        #Derivative of angular positon is angular velocity
        A[0,1] = 1
        #Derivative of position is velocity
        A[2,3] = 1

        # V_x_dot terms
        A[3,0] = self.g*self.LIFT_COEFFICIENT
        A[3,3] = -self.B_w / self.MASS

        # Theta_dot term(s)
        A[1,3] = -self.Rw*self.B_w / self.Jz

        #Note: There are no terms in the A matrix for V_z_dot because that is
        #   controlled by the altitude controller which is decoupled from this
        #   controller (the latitude controller)


        #Coefficients for input matrix B
        B[1] = 1 #/ self.Jz

        Q = np.zeros((4,4))
        #impose larger penalty on theta and theta_dot for deviating than position
        #because these deviating will cause robot to become unstable and state will diverge
        Q[0,0] = 100
        Q[1,1] = 1
        Q[2,2] = 100
        Q[3,3] = 0.1

        R = 0.001


        gains, ricatti, eigs = control.lqr(A, B, Q, R)

        return gains


    def run_lqr(self, timesteps, verbose = False, plots = True):
        print("Running Simulation with LQR controller...")

        state = np.zeros(6).reshape(6,1)
        state_desired = np.array([0.0, 0.0, 2, 0.0, 2, 0.0]).reshape(6,1)

        gains = self.LQR_gains()

        #maybe make this a while loop
        for i in range(timesteps):


            if (i==0):
                state_data = np.vstack([ state, state_desired[2] ])
                sensor_data = np.array([0.0, 0.0]).reshape(2,1)
                aVelEstimates = np.array([0.0, 0.0]).reshape(2,1)
            else:
                state_data = np.hstack([ state_data, np.vstack([state, state_desired[2]])  ])
                new_reading = self.readSensors(state[0])
                aVelEstimates = self.getAngularVel(new_reading)
                sensor_data = np.hstack([ sensor_data, aVelEstimates ])

            if i%10 == 0 and verbose:
                print(i, ":\t", state)
                if (i != 0):
                    print("A-Vel Estimates: ", aVelEstimates)

            estimated_state = state.copy()
            estimated_state[1] = aVelEstimates[0]

            self.state_estimate = estimated_state


            # JONATHAN: make it so there's only one torque_gen variable (currently there are 2)
            state, torque_gen = self.updateState_LQR_Control(estimated_state, self.dt, state_desired, gains)

            if (i==0):
                torque_data = np.array(torque_gen)
            else:
                torque_data = np.append(torque_data, torque_gen)


        state_data = np.array(state_data)
        t = np.linspace(0, self.dt*state_data.shape[1], state_data.shape[1])

        if plots:
            plt.figure(figsize=[8,6])
            plt.title("Comparing Actual and Estimated Angular Velocity")
            plt.plot(t, sensor_data[0,:], label="Estimates from Sensors")
            plt.plot(t, state_data[1,:], label="Actual Angular Velocity Values")
            plt.plot(t, state_data[0,:], label="Actual Theta Value")
            plt.ylabel("Rotational Velocity [rad/sec]")
            plt.xlabel("Time [sec]")
            plt.xlim(0,1)
            #plt.ylim(-2,2)
            plt.legend()
            plt.show()

            plt.figure(figsize=[9,7])
            plt.suptitle("LQR Controller - Position (Desired Position x=%4.2f, y=%4.2f)" % (state_desired[2], state_desired[4]))
            #plt.suptitle("LQR Controller (R = 10)")
            plt.subplot(1,2,1)
            plt.plot(state_data[2,:], state_data[4,:])
            plt.ylabel('Y [m]')
            plt.xlabel('X [m]')
            #plt.plot(t, state_data[2,:])
            #plt.ylabel('X [m]')
            #plt.xlabel("t [sec]")
            plt.grid()


            plt.subplot(1,2,2)
            plt.plot(t, state_data[0,:], label='Theta  [rad]')
            plt.plot(t, state_data[1,:], label='Omega (Theta Dot)  [rad/sec]')
            plt.xlim(0,1) #angle usually congeres within first 100 time steps of simulation
            #plt.ylim(-0.5,0.5)
            plt.xlabel("Time [sec]")
            plt.ylabel("Magnitude")
            plt.legend()
            plt.show()

        print("Done!")
        return np.transpose(state_data), torque_data


    def run_pd(self, timesteps, verbose = False, plots = True):
        print("Running simulation with PD controller...")
        seed(0) #initializes random number generator
        state = np.zeros(4)

        state[1] = -10 + (random() * 20)

        for i in range(timesteps):
            if verbose:
                print(i, ":\t", state)

            if(i % 250 == 0):
                #this conditional occasionally varies angular vel to validate functionality
                #of torque controller
                state[1] = -10 + (random() * 20)



            if (i==0):
                state_data = np.array(state)
            else:
                state_data = np.vstack([state_data, np.array(state)])

            state, torque_applied = self.updateState_PD_Control(state.copy(), self.dt)


            if (i==0):
                torques_data = np.array(torque_applied)
            else:
                torques_data = np.append(torques_data, torque_applied)

        t = np.linspace(0, self.dt*len(state_data[:,0]), len(state_data[:,0]))

        if plots:
            plt.plot(t, state_data[:,3], label='Velocity [m/s]')
            plt.plot(t, state_data[:,1], label='Angular Velocity [rad/s]')
            plt.grid()
            plt.legend()
            #plt.ylim(-10, 10)
            plt.ylabel("Magnitude")
            plt.xlabel("time [sec]")
            plt.title("State Space - PD Controller")
            plt.show()


        print("Done!")
        return state_data, torques_data


    def readSensors(self, theta):
        """ NOTE: This is a very crude estimation. Thought behind it was to use
                  the light output of a typical lightbulb (seems to be around 850 lumens)
                  and then to have the brightness adjust proportionally
                  to the angle between the vector from the robot to the light and the
                  vector normal to the sensor's surface.

                  The reading is in lux (illuminance per square meter, and I'm saying the
                  light is 1 meter away, meaning the light's luminance is spread
                  over a sphere with surface area of 4*pi*[1]^2 = pi)
        """


        """ normalize light source vector so magnitude is 1
            light vector is assumed to always be directly above the robot since it
            is far enough away that lateral movement doesn't make a difference. Think of
            the sun in relation to you as you walk around outside """
        light_vec = [0,1,0]

        light_output = 850 #output of light in lumens, typical bulbs give off 600~1200ish lumens


        init_angle = 30 * np.pi / 180

        new_sensor_orientations = np.array([ [np.cos(init_angle - theta),       np.sin(init_angle - theta),       0],
                                         [np.sin(init_angle)*np.sin(theta), np.sin(init_angle)*np.cos(theta), np.cos(init_angle)],
                                         [-np.cos(init_angle + theta),      np.sin(init_angle + theta),       0],
                                         [np.sin(init_angle)*np.sin(theta), np.sin(init_angle)*np.cos(theta), -np.cos(init_angle)] ])


        """make sure to take into account vehicle orientation when doing dot products;
        the sensor vectors are relative to the orientation of the 'bee' """

        sensor_readings = np.array([0.0, 0.0, 0.0, 0.0]).reshape(4,1)

        for i in range(new_sensor_orientations.shape[0]):

            angle = np.arccos(np.dot(light_vec, new_sensor_orientations[i]) /
                                np.linalg.norm(light_vec) * np.linalg.norm(new_sensor_orientations[i]))


            sensor_readings[i] = light_output * angle

        return sensor_readings


    def getAngularVel(self, new_readings):
        # JONATHAN: add a link to paper I got this math from

        diffs = new_readings - self.sensor_readings
        self.sensor_readings = new_readings

        # Original estimate was pi/850, added the 7468.8 to scale from obtained
        # values to desired values
        k = np.pi / (850) * 7468.8

        L = np.array([ [np.sqrt(3)/k,   0,  -np.sqrt(3)/k,    0,  ],
                       [0,  -np.sqrt(3)/k,  0,  np.sqrt(3)/k]       ])

        angular_vel_estimates = L.dot(diffs)

        angular_vel_estimates[0,0] += self.dt*self.LAST_TORQUE_GEN


        return angular_vel_estimates
